K1C Core Implementation
=======================

This documents will try to explain any architecture choice for the k1c
linux port.

Regarding the peripheral, we MUST use device tree to describe ALL
peripherals. The bindings should always start with "kalray,k1c" for all
core related peripherals (watchdog, timer, etc)

System
======

sr0 will hold the current task_struct. This register is reserved and
should not be touched by any other code.

Boot arguments
==============

When booting, the kernel will look for a special magic in $r0 (0x494C314B)
This magic tells the kernel if there is arguments passed by a bootloader.
Currently, the following values are passed through registers:
 - r1: pointer to command line setup by bootloader
 - r2: device tree

If this magic is not set, then, the command line will be the one
provided in the device tree (see bootargs). The default device tree is
not builtin but will be setup by the runner used (simulator or jtag).

A default stdout-path is desirable to allow early printk.

Boot Memory Allocator
=====================

The boot memory allocator is used to allocate memory before paging is enabled.
It is initialized with DDR and also with the shared memory. This first one is
initialized during the setup_bootmem() and the second one when calling
early_init_fdt_scan_reserved_mem().


Virtual and physical memory
===========================

The mapping used and the memory management is described in
Documentation/k1c/k1c-mmu.txt.
Our Kernel is compiled using virtual addresses that starts at
0xffffff0000000000. But when it is started the kernel uses physical addresses.
Before calling the first function arch_low_level_start() we configure 2 entries
of the LTLB.

The first entry will map the first 1G of virtual address space to the first
1G of DDR:
  - TLB[0]: 0xffffff0000000000 -> 0x80000000 (size 1Go)

The second entry will be a flat mapping of the first 512 Ko of the SMEM. It
is required to have this flat mapping because there is still code located at
this address that needs to be executed:
  - TLB[1]: 0x0 -> 0x0 (size 512Ko)

Once virtual space reached the second entry is removed.

To be able to set breakpoints when MMU is enabled we added a label called
gdb_mmu_enabled. If you try to set a breakpoint on a function that is in
virtual memory before the activation of the MMU this address as no signification
for GDB. So, for example, if you want to break on the function start_kernel()
you will need to run:

	k1-gdb -silent path_to/vmlinux \
		-ex 'tbreak gdb_mmu_enabled' -ex 'run' \
		-ex 'break start_kernel' \
		-ex 'continue'

We will also add an option to k1-gdb to simplify this step.

Timers
======

The free-runinng clock (clocksource) is based on the DSU. This clock is
not interruptible and never stops even if core go into idle.

Regarding the tick (clockevent), we use the timer 0 available on the core.
This timer allows to set a periodic tick which will be used as the main
tick for each core. Note that this clock is percpu.

get_cycles implementation is based on performance counter. One of them
is used to count cycles. Note that since this is used only when the core
is running, there is no need to worry about core sleeping (which will
stop the cycle counter)

Context switching
=================

context switching is done in entry.S. When spawning a fresh thread,
copy_thread is called. During this call, we setup callee saved register
r15 and r16 to special values containing the function to call.

The normal path for a kernel thread will be the following:

 1 - Enter copy_thread_tls and setup callee saved registers which will
     be restored in __switch_to.
 2 - set r15 and r16 (in thread_struct) to function and argument and
     ra to ret_from_kernel_thread.
     These callee saved will be restored in switch_to.
 3 - Call _switch_to at some point.
 4 - Save all callee saved register since switch_to is seen as a
     standard function call by the caller.
 5 - Change stack pointer to the new stack
 6 - At the end of switch to, set sr0 to the new task and use ret to
     jump to ret_from_kernel_thread (address restored from ra).
 7 - In ret_from_kernel_thread, execute the function with arguments by
     using r15, r16 and we are done

For more explanation, you can refer to https://lwn.net/Articles/520227/

User thread creation
====================

We are using almost the same path as copy_thread to create it.
The detailed path is the following:

 1 - Call start_thread which will setup user pc and stack pointer in
     task regs. We also set sps and clear privilege mode bit.
     When returning from exception, it will "flip" to user mode.
 2 - Enter copy_thread_tls and setup callee saved registers which will
     be restored in __switch_to. Also, set the "return" function to be
     ret_from_fork which will be called at end of switch_to
 3 - set r15 (in thread_struct) with tracing information.
     (simply by lazyness to avoid computing it in assembly...)
 4 - Call _switch_to at some point.
 5 - The current pc will then be restored to be ret_from fork.
 6 - Ret from fork calls schedule_tail and then check if tracing is
     enabled. If so call syscall_trace_exit
 7 - finally, instead of returning to kernel, we restore all registers
     that have been setup by start_thread by restoring regs stored on
     stack

Building
========

In order to build the kernel, you will need a complete k1c toolchain.
First, setup the config using the following command line

$ make ARCH=k1c O=your_directory default_defconfig

Adjust any configuration option you may need and then, build the kernel:

$ make ARCH=k1c O=your_directory -j12

You will finally have a vmlinux image ready to be run.

$ k1-mppa -- vmlinux

Additionally, you may want to debug it. To do so, use k1-gdb:

$ k1-gdb vmlinux


